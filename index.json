{"repository_name":"dexter","body":"# Dexter\n\n[![API Documentation Website](https://img.shields.io/website?down_color=red&down_message=Offline&label=API%20Documentation&up_message=Online&url=https%3A%2F%2Fluckyframework.github.io%2Fdexter%2F)](https://luckyframework.github.io/dexter)\n\nExtensions to Crystal's `Log` class.\n\n* 100% compatible with built-in Crystal's [`Log`](https://crystal-lang.org/api/latest/Log.html)\n* Adds methods for easily logging key/value data\n* Built-in `Dexter::JSONLogFormatter` for formatting Logs as JSON\n* Helper class for making log formatting simpler and more flexible\n* Simpler configuration with helpful compile-time guarantees\n* Helper methods for testing log output more easily\n\nAnd everything is optional so if you only want the JSON formatter you can just use that.\nDexter does not break the existing `Log` and is a *very* small library.\n\n## Installation\n\n1. Add the dependency to your `shard.yml`:\n\n   ```yaml\n   dependencies:\n     dexter:\n       github: luckyframework/dexter\n       version: ~> 0.3\n   ```\n\n2. Run `shards install`\n\n## Getting started example\n\n```crystal\nrequire \"dexter\"\n\nbackend = Log::IOBackend.new\nbackend.formatter = Dexter::JSONLogFormatter.proc\n# Equivalent to: Log.builder.bind \"*\", :info, backend\nLog.dexter.configure(:info, backend)\n\n# These examples use 'info' but you can use 'debug', 'warn', and 'error' as well.\n#\n# Logs timestamp, severity and {foo: \"bar\"} as JSON\nLog.dexter.info { {foo: \"bar\"} }\n\n# You can pass an exception *and* key/value data\nLog.dexter.error(exception: my_exception) { {foo: \"bar\"} }\n\n# Fully compatible with built-in Crystal Log\n#\n# Logs timestamp, severity and {message: \"My message\"} as JSON\nLog.info { \"My message\" }\n```\n\n## Type-safe Log configuration\n\nUse `{LogClass}.dexter.configure to configure `{LogClass}` and its child logs\n\nRather than pass a string `source` to `Log.builder.bind` you can configure a\nlog using its class. This is a type-safe and simpler alternative to using\n`Log.builder.bind`.\n\n## Examples:\n\n> Note: the backend can be left off and it will use the `{LogClass}`'s\n> existing backend or a new `Log::IOBackend`\n\n```crystal\n# Configure all logs.\n# Similar to `Log.builder.bind \"*\"`\nLog.dexter.configure(:info, backend)\n\n# Configure Avram::Log and all child logs\n# Similar to `Log.builder.bind \"avram.*\"\nAvram::Log.dexter.configure(:warn)\n\n# Can further customize child Logs\nAvram::QueryLog.dexter.configure(:none)\nAvram::FailedQueryLog.dexter.configure(:info, SomeOtherBackend.new)\n```\n\n`{LogClass}.dexter.configure` sets all child logs to the given\nlevel/backend . If you want to configure a Log and leave its children alone\nit is best to set the `level` or `backend` directly:\n\n```crystal\nMyShard::Log.level = :error\nMyShard::Log.backend = MyCustomBackend.new\n```\n\n## Test helpers\n\nThis will temporarily configure the given log with a `Log::IOBackend`\nwith an `IO::Memory` that is yielded. The log level is also\ntemporarily set to `:debug` to log all messages\n\n```crystal\nMyShard::Log.dexter.temp_config do |log_io|\n  MyShard::Log.info { \"log me\" }\n  log_io.to_s.should contain(\"log me\")\nend\n```\n\nThere are more options for changing the level, passing your own IO, etc. See\nthe [documentation](https://github.com/luckyframework/dexter/blob/6144739a6d1a2d0f64d95a89086495c17cafe7eb/src/dexter/log.cr#L80) for more details\n\n## Built-in formatters\n\nDexter works with *any* `Log::Formatter`, but has a JSON formatter built-in\nthat works especially well.\n\n* Logs exceptions in an easily parseable format\n```json\n{\n  \"exception\": { \"class\": \"RuntimeError\", \"message\": \"Something broke\", backtrace: [\"line_of_code.cr:123\"] }\n}\n```\n* Puts string message in a `message` key that comes first so you can find it easily\n* JSON works great for searching logs with many SaaS logging services\n\n\n## Create your own formatter\n\nIncluded is a `Dexter::JSONLogFormatter`, but you can create your own formatter to format\nand output log data however you want. For example,\n[Lucky](https://luckyframework.org) has a `PrettyLogFormatter` that formats data\nin a human readable format during development, and uses the `JSONLogFormatter`\nin production.\n\nSee an example formatter in [Dexter::JSONLogFormatter](https://github.com/luckyframework/dexter/blob/master/src/dexter/json_log_formatter.cr)\n\n## Contributing\n\n1. Fork it (<https://github.com/luckyframework/dexter/fork>)\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Commit your changes (`git commit -am 'Add some feature'`)\n4. Push to the branch (`git push origin my-new-feature`)\n5. Create a new Pull Request\n\n## Contributors\n\n- [Paul Smith](https://github.com/paulcsmith) - creator and maintainer\n","program":{"html_id":"dexter/toplevel","path":"toplevel.html","kind":"module","full_name":"Top Level Namespace","name":"Top Level Namespace","abstract":false,"superclass":null,"ancestors":[],"locations":[],"repository_name":"dexter","program":true,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[{"html_id":"dexter/Dexter","path":"Dexter.html","kind":"module","full_name":"Dexter","name":"Dexter","abstract":false,"superclass":null,"ancestors":[],"locations":[],"repository_name":"dexter","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[{"id":"VERSION","name":"VERSION","value":"\"0.3.2\"","doc":null,"summary":null}],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[{"html_id":"dexter/Dexter/BaseFormatter","path":"Dexter/BaseFormatter.html","kind":"struct","full_name":"Dexter::BaseFormatter","name":"BaseFormatter","abstract":true,"superclass":{"html_id":"dexter/Struct","kind":"struct","full_name":"Struct","name":"Struct"},"ancestors":[{"html_id":"dexter/Struct","kind":"struct","full_name":"Struct","name":"Struct"},{"html_id":"dexter/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"dexter/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[],"repository_name":"dexter","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[{"html_id":"dexter/Dexter/JSONLogFormatter","kind":"struct","full_name":"Dexter::JSONLogFormatter","name":"JSONLogFormatter"}],"including_types":[],"namespace":{"html_id":"dexter/Dexter","kind":"module","full_name":"Dexter","name":"Dexter"},"doc":null,"summary":null,"class_methods":[{"id":"proc-class-method","html_id":"proc-class-method","name":"proc","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/dexter/base_formatter.cr","line_number":5,"url":null},"def":{"name":"proc","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"::Log::Formatter.new do |entry, io|\n  (new(entry, io)).call\nend"}}],"constructors":[{"id":"new(entry:Log::Entry,io:IO)-class-method","html_id":"new(entry:Log::Entry,io:IO)-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[{"name":"entry","doc":null,"default_value":"","external_name":"entry","restriction":"Log::Entry"},{"name":"io","doc":null,"default_value":"","external_name":"io","restriction":"IO"}],"args_string":"(entry : Log::Entry, io : IO)","args_html":"(entry : Log::Entry, io : IO)","location":{"filename":"src/dexter/base_formatter.cr","line_number":11,"url":null},"def":{"name":"new","args":[{"name":"entry","doc":null,"default_value":"","external_name":"entry","restriction":"Log::Entry"},{"name":"io","doc":null,"default_value":"","external_name":"io","restriction":"IO"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize(entry, io)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"id":"call-instance-method","html_id":"call-instance-method","name":"call","doc":null,"summary":null,"abstract":true,"args":[],"args_string":"","args_html":"","location":{"filename":"src/dexter/base_formatter.cr","line_number":14,"url":null},"def":{"name":"call","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":""}},{"id":"entry:Log::Entry-instance-method","html_id":"entry:Log::Entry-instance-method","name":"entry","doc":null,"summary":null,"abstract":false,"args":[],"args_string":" : Log::Entry","args_html":" : Log::Entry","location":{"filename":"src/dexter/base_formatter.cr","line_number":3,"url":null},"def":{"name":"entry","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@entry"}},{"id":"io:IO-instance-method","html_id":"io:IO-instance-method","name":"io","doc":null,"summary":null,"abstract":false,"args":[],"args_string":" : IO","args_html":" : IO","location":{"filename":"src/dexter/base_formatter.cr","line_number":3,"url":null},"def":{"name":"io","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@io"}}],"macros":[],"types":[]},{"html_id":"dexter/Dexter/JSONLogFormatter","path":"Dexter/JSONLogFormatter.html","kind":"struct","full_name":"Dexter::JSONLogFormatter","name":"JSONLogFormatter","abstract":false,"superclass":{"html_id":"dexter/Dexter/BaseFormatter","kind":"struct","full_name":"Dexter::BaseFormatter","name":"BaseFormatter"},"ancestors":[{"html_id":"dexter/Dexter/BaseFormatter","kind":"struct","full_name":"Dexter::BaseFormatter","name":"BaseFormatter"},{"html_id":"dexter/Struct","kind":"struct","full_name":"Struct","name":"Struct"},{"html_id":"dexter/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"dexter/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[],"repository_name":"dexter","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"dexter/Dexter","kind":"module","full_name":"Dexter","name":"Dexter"},"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[{"id":"call-instance-method","html_id":"call-instance-method","name":"call","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/dexter/json_log_formatter.cr","line_number":6,"url":null},"def":{"name":"call","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"context_data = entry.context.to_h\nlocal_data = (context_data.delete(\"local\")).try(&.as_h)\ndata = default_data\nif local_data\n  data = data.merge(local_data)\nend\ndata = data.merge(context_data)\nexception_data.try do |exception_data_|\n  data = data.merge(exception_data_)\nend\ndata.compact.to_json(io)\n"}}],"macros":[],"types":[]}]},{"html_id":"dexter/Log","path":"Log.html","kind":"class","full_name":"Log","name":"Log","abstract":false,"superclass":{"html_id":"dexter/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"dexter/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"dexter/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[],"repository_name":"dexter","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":"The `Log` class provides a logging utility that you can use to output messages.\n\nThe messages, or `Log::Entry` have associated levels, such as `Info` or `Error`\nthat indicate their importance. See `Log::Severity`.\n\nTo log a message `trace`, `debug`, `info`, `notice`, `warn`, `error`, and `fatal` methods\ncan be used. They expect a block that will evaluate to the message of the entry.\n\n```\nrequire \"log\"\n\nLog.info { \"Program started\" }\n```\n\nData can be associated with a log entry via the `Log::Emitter` yielded in the logging methods.\n\n```\nLog.info &.emit(\"User logged in\", user_id: 42)\n```\n\nIf you want to log an exception, you can indicate it in the `exception:` named argument.\n\n```\nLog.warn(exception: e) { \"Oh no!\" }\nLog.warn exception: e, &.emit(\"Oh no!\", user_id: 42)\n```\n\nThe block is only evaluated if the current message is to be emitted to some `Log::Backend`.\n\nTo add structured information to the message you can use the `Log::Context`.\n\nWhen creating log messages they belong to a _source_. If the top-level `Log` is used\nas in the above examples its source is the empty string.\n\nThe source can be used to identify the module or part of the application that is logging.\nYou can configure for each source a different level to filter the messages.\n\nA recommended pattern is to declare a `Log` constant in the namespace of your shard or module as follows:\n\n```\nmodule DB\n  Log = ::Log.for(\"db\") # => Log for db source\n\n  def do_something\n    Log.info { \"this is logged in db source\" }\n  end\nend\n\nDB::Log.info { \"this is also logged in db source\" }\nLog.for(\"db\").info { \"this is also logged in db source\" }\nLog.info { \"this is logged in top-level source\" }\n```\n\nThat way, any `Log.info` call within the `DB` module will use the `db` source. And not the top-level `::Log.info`.\n\nSources can be nested. Continuing the last example, to declare a `Log` constant `db.pool` source you can do as follows:\n\n```\nclass DB::Pool\n  Log = DB::Log.for(\"pool\") # => Log for db.pool source\nend\n```\n\nA `Log` will emit the messages to the `Log::Backend`s attached to it as long as\nthe configured severity filter `level` permits it.\n\nLogs can also be created from a type directly. For the type `DB::Pool` the source `db.pool` will be used.\nFor generic types as `Foo::Bar(Baz)` the source `foo.bar` will be used (i.e. without generic arguments).\n\n```\nmodule DB\n  Log = ::Log.for(self) # => Log for db source\nend\n```\n\n### Default logging configuration\n\nBy default entries from all sources with `Info` and above severity will\nbe logged to `STDOUT` using the `Log::IOBackend`.\n\nIf you need to change the default level, backend or sources call `Log.setup` upon startup.\n\nNOTE: Calling `setup` will override previous `setup` calls.\n\n```\nLog.setup(:debug)                     # Log debug and above for all sources to STDOUT\nLog.setup(\"myapp.*, http.*\", :notice) # Log notice and above for myapp.* and http.* sources only, and log nothing for any other source.\nbackend_with_formatter = Log::IOBackend.new(formatter: custom_formatter)\nLog.setup(:debug, backend_with_formatter) # Log debug and above for all sources to using a custom backend\n```\n\n### Configure logging explicitly in the code\n\nUse `Log.setup` methods to indicate which sources should go to which backends.\n\nYou can indicate actual sources or patterns.\n\n* the empty string matches only the top-level source\n* `*` matches all the sources\n* `foo.bar.*` matches `foo.bar` and every nested source\n* `foo.bar` matches `foo.bar`, but not its nested sources\n* Any comma separated combination of the above\n\nThe following configuration will setup for all sources to emit\nwarnings (or higher) to `STDOUT`, allow any of the `db.*` and\nnested source to emit debug (or higher), and to also emit for all\nsources errors (or higher) to an elasticsearch backend.\n\n```\nLog.setup do |c|\n  backend = Log::IOBackend.new\n\n  c.bind \"*\", :warn, backend\n  c.bind \"db.*\", :debug, backend\n  c.bind \"*\", :error, ElasticSearchBackend.new(\"http://localhost:9200\")\nend\n```\n\n### Configure logging from environment variables\n\nInclude the following line to allow configuration from environment variables.\n\n```\nLog.setup_from_env\n```\n\nThe environment variable `LOG_LEVEL` is used to indicate which severity level to emit.\nBy default entries from all sources with `Info` and above severity will\nbe logged to `STDOUT` using the `Log::IOBackend`.\n\nTo change the level and sources change the environment variable value:\n\n```console\n$ LOG_LEVEL=DEBUG ./bin/app\n```\n\nYou can tweak the default values (used when `LOG_LEVEL` variable is not defined):\n\n```\nLog.setup_from_env(default_level: :error)\n```\n","summary":"<p>The <code><a href=\"Log.html\">Log</a></code> class provides a logging utility that you can use to output messages.</p>","class_methods":[{"id":"dexter:Dexter-class-method","html_id":"dexter:Dexter-class-method","name":"dexter","doc":null,"summary":null,"abstract":false,"args":[],"args_string":" : Dexter","args_html":" : <a href=\"Log/Dexter.html\">Dexter</a>","location":{"filename":"src/dexter/log.cr","line_number":30,"url":null},"def":{"name":"dexter","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Dexter","visibility":"Public","body":"Dexter.new(Log.for(\"\"))"}}],"constructors":[],"instance_methods":[{"id":"backend:Log::Backend?-instance-method","html_id":"backend:Log::Backend?-instance-method","name":"backend","doc":null,"summary":null,"abstract":false,"args":[],"args_string":" : Log::Backend?","args_html":" : Log::Backend?","location":{"filename":"src/dexter/log.cr","line_number":6,"url":null},"def":{"name":"backend","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@backend"}},{"id":"dexter:Dexter-instance-method","html_id":"dexter:Dexter-instance-method","name":"dexter","doc":null,"summary":null,"abstract":false,"args":[],"args_string":" : Dexter","args_html":" : <a href=\"Log/Dexter.html\">Dexter</a>","location":{"filename":"src/dexter/log.cr","line_number":26,"url":null},"def":{"name":"dexter","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Dexter","visibility":"Public","body":"Dexter.new(self)"}}],"macros":[],"types":[{"html_id":"dexter/Log/Builder","path":"Log/Builder.html","kind":"class","full_name":"Log::Builder","name":"Builder","abstract":false,"superclass":{"html_id":"dexter/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"dexter/Log/Configuration","kind":"module","full_name":"Log::Configuration","name":"Configuration"},{"html_id":"dexter/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"dexter/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[],"repository_name":"dexter","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[{"html_id":"dexter/Log/Configuration","kind":"module","full_name":"Log::Configuration","name":"Configuration"}],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"dexter/Log","kind":"class","full_name":"Log","name":"Log"},"doc":"A `Log::Builder` creates `Log` instances for a given source.\nIt allows you to bind sources and patterns to a given backend.\nAlready created `Log` will be reconfigured as needed.","summary":"<p>A <code><a href=\"../Log/Builder.html\">Log::Builder</a></code> creates <code><a href=\"../Log.html\">Log</a></code> instances for a given source.</p>","class_methods":[],"constructors":[],"instance_methods":[{"id":"dexter_unbind(source:String)-instance-method","html_id":"dexter_unbind(source:String)-instance-method","name":"dexter_unbind","doc":null,"summary":null,"abstract":false,"args":[{"name":"source","doc":null,"default_value":"","external_name":"source","restriction":"String"}],"args_string":"(source : String)","args_html":"(source : String)","location":{"filename":"src/dexter/log.cr","line_number":10,"url":null},"def":{"name":"dexter_unbind","args":[{"name":"source","doc":null,"default_value":"","external_name":"source","restriction":"String"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@mutex.synchronize do\n  each_log do |log|\n    if Builder.matches(log.source, source)\n      @bindings = @bindings.reject do |b|\n        b.source == log.source\n      end\n      log.backend = nil\n      log.initial_level = :none\n    end\n  end\nend"}}],"macros":[],"types":[]},{"html_id":"dexter/Log/Dexter","path":"Log/Dexter.html","kind":"struct","full_name":"Log::Dexter","name":"Dexter","abstract":false,"superclass":{"html_id":"dexter/Struct","kind":"struct","full_name":"Struct","name":"Struct"},"ancestors":[{"html_id":"dexter/Struct","kind":"struct","full_name":"Struct","name":"Struct"},{"html_id":"dexter/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"dexter/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[],"repository_name":"dexter","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[{"id":"SEVERITY_MAP","name":"SEVERITY_MAP","value":"{debug: Severity::Debug, info: Severity::Info, notice: Severity::Notice, warn: Severity::Warn, error: Severity::Error, fatal: Severity::Fatal}","doc":null,"summary":null}],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"dexter/Log","kind":"class","full_name":"Log","name":"Log"},"doc":null,"summary":null,"class_methods":[],"constructors":[{"id":"new(log:Log)-class-method","html_id":"new(log:Log)-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[{"name":"log","doc":null,"default_value":"","external_name":"log","restriction":"::Log"}],"args_string":"(log : Log)","args_html":"(log : <a href=\"../Log.html\">Log</a>)","location":{"filename":"src/dexter/log.cr","line_number":46,"url":null},"def":{"name":"new","args":[{"name":"log","doc":null,"default_value":"","external_name":"log","restriction":"::Log"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize(log)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"id":"configure(severity:Log::Severity,backend:Log::Backend):Nil-instance-method","html_id":"configure(severity:Log::Severity,backend:Log::Backend):Nil-instance-method","name":"configure","doc":"Configure a Log and all child logs\n\nThis is a type-safe and simpler alternative to using `Log.builder.bind`.\nRather than pass a string `source` you can configure a log using\nits class.\n\nThe backend can be left off and it will use the log's existing backend or\na new `Log::IOBackend`\n\nIt also sets all child logs to the same configuration since this is\nthe most common way to configure logs. If you want to configure a log and\nnone of its children it is best to set the `level` or `backend` directly:\n\n```\nMyShard::Log.level = :error\nMyShard::Log.backend = MyCustomBackend.new\n```\n\n## Examples:\n\n```\n# Configure all logs.\n# Similar to `Log.builder.bind \"*\"`\nLog.dexter.configure(:info, backend)\n\n# Configure Avram::Log and all child logs\n# Similar to `Log.builder.bind \"avram.*\"\nAvram::Log.dexter.configure(:warn)\n\n# Can further customize child Logs\nAvram::QueryLog.dexter.configure(:none)\nAvram::FailedQueryLog.dexter.configure(:info, SomeOtherBackend.new)\n```","summary":"<p>Configure a Log and all child logs</p>","abstract":false,"args":[{"name":"severity","doc":null,"default_value":"","external_name":"severity","restriction":"Log::Severity"},{"name":"backend","doc":null,"default_value":"","external_name":"backend","restriction":"Log::Backend"}],"args_string":"(severity : Log::Severity, backend : Log::Backend) : Nil","args_html":"(severity : Log::Severity, backend : Log::Backend) : Nil","location":{"filename":"src/dexter/log.cr","line_number":82,"url":null},"def":{"name":"configure","args":[{"name":"severity","doc":null,"default_value":"","external_name":"severity","restriction":"Log::Severity"},{"name":"backend","doc":null,"default_value":"","external_name":"backend","restriction":"Log::Backend"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Nil","visibility":"Public","body":"::Log.builder.dexter_unbind(source_for_bind)\n::Log.builder.bind(source_for_bind, severity, backend)\n"}},{"id":"debug(*,exception:Exception?=nil,&block:->NamedTuple|Hash):Nil-instance-method","html_id":"debug(*,exception:Exception?=nil,&block:->NamedTuple|Hash):Nil-instance-method","name":"debug","doc":"Logs key/value data in the Log::Context under the 'local' key\n\n```\nLog.dexter.debug { {path: \"/comments\", status: 200 }}\n```\n\nYou can also pass an exception:\n\n```\nLog.dexter.debug(exception) { { query: \"SELECT *\" } }\n```","summary":"<p>Logs key/value data in the Log::Context under the 'local' key</p>","abstract":false,"args":[{"name":"","doc":null,"default_value":"","external_name":"","restriction":""},{"name":"exception","doc":null,"default_value":"nil","external_name":"exception","restriction":"Exception | ::Nil"}],"args_string":"(*, exception : Exception? = <span class=\"n\">nil</span>, &block :  -> NamedTuple | Hash) : Nil","args_html":"(*, exception : Exception? = <span class=\"n\">nil</span>, &block :  -> NamedTuple | Hash) : Nil","location":{"filename":"src/dexter/log.cr","line_number":166,"url":null},"def":{"name":"debug","args":[{"name":"","doc":null,"default_value":"","external_name":"","restriction":""},{"name":"exception","doc":null,"default_value":"nil","external_name":"exception","restriction":"Exception | ::Nil"}],"double_splat":null,"splat_index":0,"yields":0,"block_arg":{"name":"block","doc":null,"default_value":"","external_name":"block","restriction":"(-> NamedTuple | Hash)"},"return_type":"Nil","visibility":"Public","body":"if backend = log.backend\nelse\n  return\nend\nseverity = Severity.new(Severity::Debug)\nif log.level <= severity\nelse\n  return\nend\nblock_result = yield\nLog.with_context do\n  Log.context.set(local: block_result)\n  log.debug(exception: exception) do\n    \"\"\n  end\nend\n"}},{"id":"error(*,exception:Exception?=nil,&block:->NamedTuple|Hash):Nil-instance-method","html_id":"error(*,exception:Exception?=nil,&block:->NamedTuple|Hash):Nil-instance-method","name":"error","doc":"Logs key/value data in the Log::Context under the 'local' key\n\n```\nLog.dexter.error { {path: \"/comments\", status: 200 }}\n```\n\nYou can also pass an exception:\n\n```\nLog.dexter.error(exception) { { query: \"SELECT *\" } }\n```","summary":"<p>Logs key/value data in the Log::Context under the 'local' key</p>","abstract":false,"args":[{"name":"","doc":null,"default_value":"","external_name":"","restriction":""},{"name":"exception","doc":null,"default_value":"nil","external_name":"exception","restriction":"Exception | ::Nil"}],"args_string":"(*, exception : Exception? = <span class=\"n\">nil</span>, &block :  -> NamedTuple | Hash) : Nil","args_html":"(*, exception : Exception? = <span class=\"n\">nil</span>, &block :  -> NamedTuple | Hash) : Nil","location":{"filename":"src/dexter/log.cr","line_number":166,"url":null},"def":{"name":"error","args":[{"name":"","doc":null,"default_value":"","external_name":"","restriction":""},{"name":"exception","doc":null,"default_value":"nil","external_name":"exception","restriction":"Exception | ::Nil"}],"double_splat":null,"splat_index":0,"yields":0,"block_arg":{"name":"block","doc":null,"default_value":"","external_name":"block","restriction":"(-> NamedTuple | Hash)"},"return_type":"Nil","visibility":"Public","body":"if backend = log.backend\nelse\n  return\nend\nseverity = Severity.new(Severity::Error)\nif log.level <= severity\nelse\n  return\nend\nblock_result = yield\nLog.with_context do\n  Log.context.set(local: block_result)\n  log.error(exception: exception) do\n    \"\"\n  end\nend\n"}},{"id":"fatal(*,exception:Exception?=nil,&block:->NamedTuple|Hash):Nil-instance-method","html_id":"fatal(*,exception:Exception?=nil,&block:->NamedTuple|Hash):Nil-instance-method","name":"fatal","doc":"Logs key/value data in the Log::Context under the 'local' key\n\n```\nLog.dexter.fatal { {path: \"/comments\", status: 200 }}\n```\n\nYou can also pass an exception:\n\n```\nLog.dexter.fatal(exception) { { query: \"SELECT *\" } }\n```","summary":"<p>Logs key/value data in the Log::Context under the 'local' key</p>","abstract":false,"args":[{"name":"","doc":null,"default_value":"","external_name":"","restriction":""},{"name":"exception","doc":null,"default_value":"nil","external_name":"exception","restriction":"Exception | ::Nil"}],"args_string":"(*, exception : Exception? = <span class=\"n\">nil</span>, &block :  -> NamedTuple | Hash) : Nil","args_html":"(*, exception : Exception? = <span class=\"n\">nil</span>, &block :  -> NamedTuple | Hash) : Nil","location":{"filename":"src/dexter/log.cr","line_number":166,"url":null},"def":{"name":"fatal","args":[{"name":"","doc":null,"default_value":"","external_name":"","restriction":""},{"name":"exception","doc":null,"default_value":"nil","external_name":"exception","restriction":"Exception | ::Nil"}],"double_splat":null,"splat_index":0,"yields":0,"block_arg":{"name":"block","doc":null,"default_value":"","external_name":"block","restriction":"(-> NamedTuple | Hash)"},"return_type":"Nil","visibility":"Public","body":"if backend = log.backend\nelse\n  return\nend\nseverity = Severity.new(Severity::Fatal)\nif log.level <= severity\nelse\n  return\nend\nblock_result = yield\nLog.with_context do\n  Log.context.set(local: block_result)\n  log.fatal(exception: exception) do\n    \"\"\n  end\nend\n"}},{"id":"info(*,exception:Exception?=nil,&block:->NamedTuple|Hash):Nil-instance-method","html_id":"info(*,exception:Exception?=nil,&block:->NamedTuple|Hash):Nil-instance-method","name":"info","doc":"Logs key/value data in the Log::Context under the 'local' key\n\n```\nLog.dexter.info { {path: \"/comments\", status: 200 }}\n```\n\nYou can also pass an exception:\n\n```\nLog.dexter.info(exception) { { query: \"SELECT *\" } }\n```","summary":"<p>Logs key/value data in the Log::Context under the 'local' key</p>","abstract":false,"args":[{"name":"","doc":null,"default_value":"","external_name":"","restriction":""},{"name":"exception","doc":null,"default_value":"nil","external_name":"exception","restriction":"Exception | ::Nil"}],"args_string":"(*, exception : Exception? = <span class=\"n\">nil</span>, &block :  -> NamedTuple | Hash) : Nil","args_html":"(*, exception : Exception? = <span class=\"n\">nil</span>, &block :  -> NamedTuple | Hash) : Nil","location":{"filename":"src/dexter/log.cr","line_number":166,"url":null},"def":{"name":"info","args":[{"name":"","doc":null,"default_value":"","external_name":"","restriction":""},{"name":"exception","doc":null,"default_value":"nil","external_name":"exception","restriction":"Exception | ::Nil"}],"double_splat":null,"splat_index":0,"yields":0,"block_arg":{"name":"block","doc":null,"default_value":"","external_name":"block","restriction":"(-> NamedTuple | Hash)"},"return_type":"Nil","visibility":"Public","body":"if backend = log.backend\nelse\n  return\nend\nseverity = Severity.new(Severity::Info)\nif log.level <= severity\nelse\n  return\nend\nblock_result = yield\nLog.with_context do\n  Log.context.set(local: block_result)\n  log.info(exception: exception) do\n    \"\"\n  end\nend\n"}},{"id":"log:Log-instance-method","html_id":"log:Log-instance-method","name":"log","doc":null,"summary":null,"abstract":false,"args":[],"args_string":" : Log","args_html":" : <a href=\"../Log.html\">Log</a>","location":{"filename":"src/dexter/log.cr","line_number":44,"url":null},"def":{"name":"log","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@log"}},{"id":"notice(*,exception:Exception?=nil,&block:->NamedTuple|Hash):Nil-instance-method","html_id":"notice(*,exception:Exception?=nil,&block:->NamedTuple|Hash):Nil-instance-method","name":"notice","doc":"Logs key/value data in the Log::Context under the 'local' key\n\n```\nLog.dexter.notice { {path: \"/comments\", status: 200 }}\n```\n\nYou can also pass an exception:\n\n```\nLog.dexter.notice(exception) { { query: \"SELECT *\" } }\n```","summary":"<p>Logs key/value data in the Log::Context under the 'local' key</p>","abstract":false,"args":[{"name":"","doc":null,"default_value":"","external_name":"","restriction":""},{"name":"exception","doc":null,"default_value":"nil","external_name":"exception","restriction":"Exception | ::Nil"}],"args_string":"(*, exception : Exception? = <span class=\"n\">nil</span>, &block :  -> NamedTuple | Hash) : Nil","args_html":"(*, exception : Exception? = <span class=\"n\">nil</span>, &block :  -> NamedTuple | Hash) : Nil","location":{"filename":"src/dexter/log.cr","line_number":166,"url":null},"def":{"name":"notice","args":[{"name":"","doc":null,"default_value":"","external_name":"","restriction":""},{"name":"exception","doc":null,"default_value":"nil","external_name":"exception","restriction":"Exception | ::Nil"}],"double_splat":null,"splat_index":0,"yields":0,"block_arg":{"name":"block","doc":null,"default_value":"","external_name":"block","restriction":"(-> NamedTuple | Hash)"},"return_type":"Nil","visibility":"Public","body":"if backend = log.backend\nelse\n  return\nend\nseverity = Severity.new(Severity::Notice)\nif log.level <= severity\nelse\n  return\nend\nblock_result = yield\nLog.with_context do\n  Log.context.set(local: block_result)\n  log.notice(exception: exception) do\n    \"\"\n  end\nend\n"}},{"id":"temp_config(io:IO=IO::Memory.new,level:Log::Severity=Log::Severity::Debug,formatter:Log::Formatter?=nil,&):Nil-instance-method","html_id":"temp_config(io:IO=IO::Memory.new,level:Log::Severity=Log::Severity::Debug,formatter:Log::Formatter?=nil,&):Nil-instance-method","name":"temp_config","doc":"Temporarily reconfigure a Log\n\nThis is mostly helpful when running tests for your log messages. This can\nmake sure you are logging what you expect to log.\n\nIf you leave off args the method will yield an `IO::Memory` and set the\nlevel to `Debug` so it logs all messages.\n\nThere are also options to configure the `IO`, `Log::Severity`, or\n`Log::Formatter` used.\n\nOnce the block ends or raises an exception the Log's configuration will\nbe reverted to its original state.\n\n## Examples\n\n```\nMyShard::Log.dexter.temp_config do |log_io|\n  MyShard::Log.info { \"log me\" }\n  log_io.to_s.should contain(\"log me\")\nend\n\nmy_own_io = IO::Memory.new\nMyShard::Log.dexter.temp_config(my_own_io) do\n  MyShard::Log.info { \"log me\" }\n  my_own_io.to_s.should contain(\"log me\")\nend\n\nformatter = ::Log::Formatter.new do |entry, io|\n  io << entry.severity\nend\n\nMyShard::Log.dexter.temp_config(level: :info, formatter: formatter) do |log_io|\n  MyShard::Log.info { \"log me\" }\n  # This is a useless test, but is here to show what can be done\n  # with the formatter option. In this case, just log severity:\n  my_own_io.to_s.chomp.should eq(\"Info\")\nend\n```\n\nYou can use any combination of `io`, `level`, `formatter`. All are optional.","summary":"<p>Temporarily reconfigure a Log</p>","abstract":false,"args":[{"name":"io","doc":null,"default_value":"IO::Memory.new","external_name":"io","restriction":"IO"},{"name":"level","doc":null,"default_value":"Log::Severity::Debug","external_name":"level","restriction":"::Log::Severity"},{"name":"formatter","doc":null,"default_value":"nil","external_name":"formatter","restriction":"::Log::Formatter | ::Nil"}],"args_string":"(io : IO = <span class=\"t\">IO</span><span class=\"t\">::</span><span class=\"t\">Memory</span>.<span class=\"k\">new</span>, level : Log::Severity = <span class=\"t\">Log</span><span class=\"t\">::</span><span class=\"t\">Severity</span><span class=\"t\">::</span><span class=\"t\">Debug</span>, formatter : Log::Formatter? = <span class=\"n\">nil</span>, &) : Nil","args_html":"(io : IO = <span class=\"t\">IO</span><span class=\"t\">::</span><span class=\"t\">Memory</span>.<span class=\"k\">new</span>, level : Log::Severity = <span class=\"t\">Log</span><span class=\"t\">::</span><span class=\"t\">Severity</span><span class=\"t\">::</span><span class=\"t\">Debug</span>, formatter : Log::Formatter? = <span class=\"n\">nil</span>, &) : Nil","location":{"filename":"src/dexter/log.cr","line_number":142,"url":null},"def":{"name":"temp_config","args":[{"name":"io","doc":null,"default_value":"IO::Memory.new","external_name":"io","restriction":"IO"},{"name":"level","doc":null,"default_value":"Log::Severity::Debug","external_name":"level","restriction":"::Log::Severity"},{"name":"formatter","doc":null,"default_value":"nil","external_name":"formatter","restriction":"::Log::Formatter | ::Nil"}],"double_splat":null,"splat_index":null,"yields":1,"block_arg":null,"return_type":"Nil","visibility":"Public","body":"log_class = ::Log.for(log.source)\noriginal_backend = log_class.backend\noriginal_level = log_class.level\nbegin\n  backend = Log::IOBackend.new(io)\n  {% if (compare_versions(Crystal::VERSION, \"0.36.0-0\")) >= 0 %}\n          backend.dispatcher = Log::Dispatcher.for(:sync)\n        {% end %}\n  if formatter\n    backend.formatter = formatter\n  end\n  log_class.level = level\n  log_class.backend = backend\n  yield io\nensure\n  log_class.backend = original_backend\n  log_class.level = original_level\nend\n"}},{"id":"warn(*,exception:Exception?=nil,&block:->NamedTuple|Hash):Nil-instance-method","html_id":"warn(*,exception:Exception?=nil,&block:->NamedTuple|Hash):Nil-instance-method","name":"warn","doc":"Logs key/value data in the Log::Context under the 'local' key\n\n```\nLog.dexter.warn { {path: \"/comments\", status: 200 }}\n```\n\nYou can also pass an exception:\n\n```\nLog.dexter.warn(exception) { { query: \"SELECT *\" } }\n```","summary":"<p>Logs key/value data in the Log::Context under the 'local' key</p>","abstract":false,"args":[{"name":"","doc":null,"default_value":"","external_name":"","restriction":""},{"name":"exception","doc":null,"default_value":"nil","external_name":"exception","restriction":"Exception | ::Nil"}],"args_string":"(*, exception : Exception? = <span class=\"n\">nil</span>, &block :  -> NamedTuple | Hash) : Nil","args_html":"(*, exception : Exception? = <span class=\"n\">nil</span>, &block :  -> NamedTuple | Hash) : Nil","location":{"filename":"src/dexter/log.cr","line_number":166,"url":null},"def":{"name":"warn","args":[{"name":"","doc":null,"default_value":"","external_name":"","restriction":""},{"name":"exception","doc":null,"default_value":"nil","external_name":"exception","restriction":"Exception | ::Nil"}],"double_splat":null,"splat_index":0,"yields":0,"block_arg":{"name":"block","doc":null,"default_value":"","external_name":"block","restriction":"(-> NamedTuple | Hash)"},"return_type":"Nil","visibility":"Public","body":"if backend = log.backend\nelse\n  return\nend\nseverity = Severity.new(Severity::Warn)\nif log.level <= severity\nelse\n  return\nend\nblock_result = yield\nLog.with_context do\n  Log.context.set(local: block_result)\n  log.warn(exception: exception) do\n    \"\"\n  end\nend\n"}}],"macros":[],"types":[]}]}]}}